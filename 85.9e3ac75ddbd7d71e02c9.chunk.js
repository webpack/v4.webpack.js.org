(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{346:function(e,n,s){"use strict";s.r(n),n.default='<p>The <code>webpack</code> compiler can understand modules written as ES2015 modules, CommonJS or AMD. However, some third party libraries may expect global dependencies (e.g. <code>$</code> for <code>jQuery</code>). The libraries might also create globals which need to be exported. These "broken modules" are one instance where <em>shimming</em> comes into play.</p>\n<blockquote class="warning">\n<p><strong>We don\'t recommend using globals!</strong> The whole concept behind webpack is to allow more modular front-end development. This means writing isolated modules that are well contained and do not rely on hidden dependencies (e.g. globals). Please use these features only when necessary.</p>\n</blockquote>\n<p>Another instance where <em>shimming</em> can be useful is when you want to <a href="https://en.wikipedia.org/wiki/Polyfill_%28programming%29">polyfill</a> browser functionality to support more users. In this case, you may only want to deliver those polyfills to the browsers that need patching (i.e. load them on demand).</p>\n<p>The following article will walk through both of these use cases.</p>\n<blockquote class="tip">\n<p>For simplicity, this guide stems from the examples in <a href="/guides/getting-started">Getting Started</a>. Please make sure you are familiar with the setup there before moving on.</p>\n</blockquote>\n<h2 id="shimming-globals">Shimming Globals<a href="#shimming-globals" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>Let\'s start with the first use case of shimming global variables. Before we do anything let\'s take another look at our project:</p>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n|- /src\n  |- index.js\n|- /node_modules</code></pre>\n<p>Remember that <code>lodash</code> package we were using? For demonstration purposes, let\'s say we wanted to instead provide this as a global throughout our application. To do this, we can use <code>ProvidePlugin</code>.</p>\n<p>The <a href="/plugins/provide-plugin"><code>ProvidePlugin</code></a> makes a package available as a variable in every module compiled through webpack. If webpack sees that variable used, it will include the given package in the final bundle. Let\'s go ahead by removing the <code>import</code> statement for <code>lodash</code> and instead provide it via the plugin:</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token deleted">- import _ from \'lodash\';</span>\n<span class="token deleted">-</span>\n  function component() {\n    const element = document.createElement(\'div\');\n\n<span class="token deleted">-   // Lodash, now imported by this script</span>\n    element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n<span class="token inserted">+ const webpack = require(\'webpack\');</span>\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n      filename: \'bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n<span class="token inserted">+   plugins: [</span>\n<span class="token inserted">+     new webpack.ProvidePlugin({</span>\n<span class="token inserted">+       _: \'lodash\',</span>\n<span class="token inserted">+     }),</span>\n<span class="token inserted">+   ],</span>\n  };</code></pre>\n<p>What we\'ve essentially done here is tell webpack...</p>\n<blockquote>\n<p>If you encounter at least one instance of the variable <code>_</code>, include the <code>lodash</code> package and provide it to the modules that need it.</p>\n</blockquote>\n<p>If we run a build, we should still see the same output:</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n    Asset    Size  Chunks                    Chunk Names\nbundle.js  544 kB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  main\n<span class="token punctuation">..</span>.</code></pre>\n<p>We can also use the <code>ProvidePlugin</code> to expose a single export of a module by configuring it with an "array path" (e.g. <code>[module, child, ...children?]</code>). So let\'s imagine we only wanted to provide the <code>join</code> method from <code>lodash</code> wherever it\'s invoked:</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff">  function component() {\n    const element = document.createElement(\'div\');\n\n<span class="token deleted">-   element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');</span>\n<span class="token inserted">+   element.innerHTML = join([\'Hello\', \'webpack\'], \' \');</span>\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const webpack = require(\'webpack\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n      filename: \'bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n    plugins: [\n      new webpack.ProvidePlugin({\n<span class="token deleted">-       _: \'lodash\',</span>\n<span class="token inserted">+       join: [\'lodash\', \'join\'],</span>\n      }),\n    ],\n  };</code></pre>\n<p>This would go nicely with <a href="/guides/tree-shaking">Tree Shaking</a> as the rest of the <code>lodash</code> library should get dropped.</p>\n<h2 id="granular-shimming">Granular Shimming<a href="#granular-shimming" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>Some legacy modules rely on <code>this</code> being the <code>window</code> object. Let\'s update our <code>index.js</code> so this is the case:</p>\n<pre><code class="hljs language-diff">  function component() {\n    const element = document.createElement(\'div\');\n\n    element.innerHTML = join([\'Hello\', \'webpack\'], \' \');\n<span class="token inserted">+</span>\n<span class="token inserted">+   // Assume we are in the context of `window`</span>\n<span class="token inserted">+   this.alert(\'Hmmm, this probably isn\\\'t a great idea...\')</span>\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p>This becomes a problem when the module is executed in a CommonJS context where <code>this</code> is equal to <code>module.exports</code>. In this case you can override <code>this</code> using the <a href="/loaders/imports-loader/"><code>imports-loader</code></a>:</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const webpack = require(\'webpack\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n      filename: \'bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n<span class="token inserted">+   module: {</span>\n<span class="token inserted">+     rules: [</span>\n<span class="token inserted">+       {</span>\n<span class="token inserted">+         test: require.resolve(\'index.js\'),</span>\n<span class="token inserted">+         use: \'imports-loader?this=>window\',</span>\n<span class="token inserted">+       },</span>\n<span class="token inserted">+     ],</span>\n<span class="token inserted">+   },</span>\n    plugins: [\n      new webpack.ProvidePlugin({\n        join: [\'lodash\', \'join\'],\n      }),\n    ],\n  };</code></pre>\n<h2 id="global-exports">Global Exports<a href="#global-exports" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>Let\'s say a library creates a global variable that it expects its consumers to use. We can add a small module to our setup to demonstrate this:</p>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">  webpack-demo\n  |- package.json\n  |- webpack.config.js\n  |- /dist\n  |- /src\n    |- index.js\n<span class="token inserted">+   |- globals.js</span>\n  |- /node_modules</code></pre>\n<p><strong>src/globals.js</strong></p>\n<pre><code class="hljs language-js"><span class="token keyword">const</span> file <span class="token operator">=</span> <span class="token string">\'blah.txt\'</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> helpers <span class="token operator">=</span> <span class="token punctuation">{</span>\n  test<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'test something\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  parse<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'parse something\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p>Now, while you\'d likely never do this in your own source code, you may encounter a dated library you\'d like to use that contains similar code to what\'s shown above. In this case, we can use <a href="/loaders/exports-loader/"><code>exports-loader</code></a>, to export that global variable as a normal module export. For instance, in order to export <code>file</code> as <code>file</code> and <code>helpers.parse</code> as <code>parse</code>:</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const webpack = require(\'webpack\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n      filename: \'bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n    module: {\n      rules: [\n        {\n          test: require.resolve(\'index.js\'),\n          use: \'imports-loader?this=>window\',\n        },\n<span class="token inserted">+       {</span>\n<span class="token inserted">+         test: require.resolve(\'globals.js\'),</span>\n<span class="token inserted">+         use: \'exports-loader?file,parse=helpers.parse\',</span>\n<span class="token inserted">+       },</span>\n      ],\n    },\n    plugins: [\n      new webpack.ProvidePlugin({\n        join: [\'lodash\', \'join\'],\n      }),\n    ],\n  };</code></pre>\n<p>Now from within our entry script (i.e. <code>src/index.js</code>), we could <code>import { file, parse } from \'./globals.js\';</code> and all should work smoothly.</p>\n<h2 id="loading-polyfills">Loading Polyfills<a href="#loading-polyfills" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>Almost everything we\'ve discussed thus far has been in relation to handling legacy packages. Let\'s move on to our second topic: <strong>polyfills</strong>.</p>\n<p>There\'s a lot of ways to load polyfills. For example, to include the <a href="https://babeljs.io/docs/en/babel-polyfill/"><code>babel-polyfill</code></a> we might simply:</p>\n<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save babel-polyfill</code></pre>\n<p>and <code>import</code> it so as to include it in our main bundle:</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token inserted">+ import \'babel-polyfill\';</span>\n<span class="token inserted">+</span>\n  function component() {\n    const element = document.createElement(\'div\');\n\n    element.innerHTML = join([\'Hello\', \'webpack\'], \' \');\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<blockquote class="tip">\n<p>Note that we aren\'t binding the <code>import</code> to a variable. This is because polyfills simply run on their own, prior to the rest of the code base, allowing us to then assume certain native functionality exists.</p>\n</blockquote>\n<p>Note that this approach prioritizes correctness over bundle size. To be safe and robust, polyfills/shims must run <strong>before all other code</strong>, and thus either need to load synchronously, or, all app code needs to load after all polyfills/shims load.\nThere are many misconceptions in the community, as well, that modern browsers "don\'t need" polyfills, or that polyfills/shims merely serve to add missing features - in fact, they often <em>repair broken implementations</em>, even in the most modern of browsers.\nThe best practice thus remains to unconditionally and synchronously load all polyfills/shims, despite the bundle size cost this incurs.</p>\n<p>If you feel that you have mitigated these concerns and wish to incur the risk of brokenness, here\'s one way you might do it:\nLet\'s move our <code>import</code> to a new file and add the <a href="https://github.com/github/fetch"><code>whatwg-fetch</code></a> polyfill:</p>\n<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save whatwg-fetch</code></pre>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token deleted">- import \'babel-polyfill\';</span>\n<span class="token deleted">-</span>\n  function component() {\n    const element = document.createElement(\'div\');\n\n    element.innerHTML = join([\'Hello\', \'webpack\'], \' \');\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">  webpack-demo\n  |- package.json\n  |- webpack.config.js\n  |- /dist\n  |- /src\n    |- index.js\n    |- globals.js\n<span class="token inserted">+   |- polyfills.js</span>\n  |- /node_modules</code></pre>\n<p><strong>src/polyfills.js</strong></p>\n<pre><code class="hljs language-javascript"><span class="token keyword">import</span> <span class="token string">\'babel-polyfill\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'whatwg-fetch\'</span><span class="token punctuation">;</span></code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const webpack = require(\'webpack\');\n\n  module.exports = {\n<span class="token deleted">-   entry: \'./src/index.js\',</span>\n<span class="token inserted">+   entry: {</span>\n<span class="token inserted">+     polyfills: \'./src/polyfills.js\',</span>\n<span class="token inserted">+     index: \'./src/index.js\',</span>\n<span class="token inserted">+   },</span>\n    output: {\n<span class="token deleted">-     filename: \'bundle.js\',</span>\n<span class="token inserted">+     filename: \'[name].bundle.js\',</span>\n      path: path.resolve(__dirname, \'dist\'),\n    },\n    module: {\n      rules: [\n        {\n          test: require.resolve(\'index.js\'),\n          use: \'imports-loader?this=>window\',\n        },\n        {\n          test: require.resolve(\'globals.js\'),\n          use: \'exports-loader?file,parse=helpers.parse\',\n        },\n      ],\n    },\n    plugins: [\n      new webpack.ProvidePlugin({\n        join: [\'lodash\', \'join\'],\n      }),\n    ],\n  };</code></pre>\n<p>With that in place, we can add the logic to conditionally load our new <code>polyfills.bundle.js</code> file. How you make this decision depends on the technologies and browsers you need to support. We\'ll just do some simple testing to determine whether our polyfills are needed:</p>\n<p><strong>dist/index.html</strong></p>\n<pre><code class="hljs language-diff">  &#x3C;!doctype html>\n  &#x3C;html>\n    &#x3C;head>\n      &#x3C;title>Getting Started&#x3C;/title>\n<span class="token inserted">+     &#x3C;script></span>\n<span class="token inserted">+       const modernBrowser = (</span>\n<span class="token inserted">+         \'fetch\' in window &#x26;&#x26;</span>\n<span class="token inserted">+         \'assign\' in Object</span>\n<span class="token inserted">+       );</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+       if ( !modernBrowser ) {</span>\n<span class="token inserted">+         const scriptElement = document.createElement(\'script\');</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+         scriptElement.async = false;</span>\n<span class="token inserted">+         scriptElement.src = \'/polyfills.bundle.js\';</span>\n<span class="token inserted">+         document.head.appendChild(scriptElement);</span>\n<span class="token inserted">+       }</span>\n<span class="token inserted">+     &#x3C;/script></span>\n    &#x3C;/head>\n    &#x3C;body>\n      &#x3C;script src="index.bundle.js">&#x3C;/script>\n    &#x3C;/body>\n  &#x3C;/html></code></pre>\n<p>Now we can <code>fetch</code> some data within our entry script:</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff">  function component() {\n    const element = document.createElement(\'div\');\n\n    element.innerHTML = join([\'Hello\', \'webpack\'], \' \');\n\n    return element;\n  }\n\n  document.body.appendChild(component());\n<span class="token inserted">+</span>\n<span class="token inserted">+ fetch(\'https://jsonplaceholder.typicode.com/users\')</span>\n<span class="token inserted">+   .then(response => response.json())</span>\n<span class="token inserted">+   .then(json => {</span>\n<span class="token inserted">+     console.log(\'We retrieved some data! AND we\\\'re confident it will work on a variety of browser distributions.\')</span>\n<span class="token inserted">+     console.log(json)</span>\n<span class="token inserted">+   })</span>\n<span class="token inserted">+   .catch(error => console.error(\'Something went wrong when fetching this data: \', error))</span></code></pre>\n<p>If we run our build, another <code>polyfills.bundle.js</code> file will be emitted and everything should still run smoothly in the browser. Note that this set up could likely be improved upon but it should give you a good idea of how you can provide polyfills only to the users that actually need them.</p>\n<h2 id="further-optimizations">Further Optimizations<a href="#further-optimizations" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>The <code>babel-preset-env</code> package uses <a href="https://github.com/browserslist/browserslist">browserslist</a> to transpile only what is not supported in your browsers matrix. This preset comes with the <a href="https://babeljs.io/docs/en/babel-preset-env#usebuiltins"><code>useBuiltIns</code></a> option, <code>false</code> by default, which converts your global <code>babel-polyfill</code> import to a more granular feature by feature <code>import</code> pattern:</p>\n<pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">\'core-js/modules/es7.string.pad-start\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'core-js/modules/es7.string.pad-end\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'core-js/modules/web.timers\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'core-js/modules/web.immediate\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'core-js/modules/web.dom.iterable\'</span><span class="token punctuation">;</span></code></pre>\n<p>See <a href="https://babeljs.io/docs/en/babel-preset-env">the babel-preset-env documentation</a> for more information.</p>\n<h2 id="node-built-ins">Node Built-Ins<a href="#node-built-ins" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>Node built-ins, like <code>process</code>, can be polyfilled right directly from your configuration file without the use of any special loaders or plugins. See the <a href="/configuration/node">node configuration page</a> for more information and examples.</p>\n<h2 id="other-utilities">Other Utilities<a href="#other-utilities" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>There are a few other tools that can help when dealing with legacy modules.</p>\n<p>The <a href="/loaders/script-loader/"><code>script-loader</code></a> evaluates code in the global context, similar to inclusion via a <code>script</code> tag. In this mode, every normal library should work. <code>require</code>, <code>module</code>, etc. are undefined.</p>\n<blockquote class="warning">\n<p>When using the <code>script-loader</code>, the module is added as a string to the bundle. It is not minimized by <code>webpack</code>, so use a minimized version. There is also no <code>devtool</code> support for libraries added by this loader.</p>\n</blockquote>\n<p>When there is no AMD/CommonJS version of the module and you want to include the <code>dist</code>, you can flag this module in <a href="/configuration/module/#modulenoparse"><code>noParse</code></a>. This will cause webpack to include the module without parsing it or resolving <code>require()</code> and <code>import</code> statements. This practice is also used to improve the build performance.</p>\n<blockquote class="warning">\n<p>Any feature requiring the AST, like the <code>ProvidePlugin</code>, will not work.</p>\n</blockquote>\n<p>Lastly, there are some modules that support multiple <a href="/concepts/modules">module styles</a>; e.g. a combination of AMD, CommonJS, and legacy. In most of these cases, they first check for <code>define</code> and then use some quirky code to export properties. In these cases, it could help to force the CommonJS path by setting <code>define=>false</code> via the <a href="/loaders/imports-loader/"><code>imports-loader</code></a>.</p>\n'}}]);